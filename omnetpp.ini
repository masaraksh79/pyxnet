[General]
network = Pyxis
#debug-on-errors = true
record-eventlog = true
num-rngs=3
sim-time-limit = 10s

# one mini-slot assumption
# ____/-------------\_____
#  rx-tx               tx-rx
#              120b
#  330us                70us
#      ------2.5ms----
# assume 10 header bytes

Pyxis.numHosts = 15
Pyxis.slotTime = 2.5ms    # mini-slot size
Pyxis.txRate = 38.2kbps
Pyxis.slotBytes = 110		  		# see picture above

# Number of cycle slots is initially equals to ARSInitial and can go up to cycleSlots
# Without data every AR the BCS is transmitted and everything is access.
# If data is issued the data cycle grows until it reaches cycleSlots and then starts to cut allocations
Pyxis.cycleSlots = 100	 		# maximum possible number of slots in cycle

# In addition to harmonic backoff the cycle size increases by 1 every time the 
# number of slots with collision goes above half. It can go up to ARSmax at most
Pyxis.server.ARSmax = 19            # maximum size of Access Requests slots
Pyxis.server.ARSmin = 4 	   			# minimal size of Access Requests slots	

Pyxis.host[*].radioDelay = 1us
Pyxis.host[*].randomStart = 30 	# within N mini-slots
[Config Pyxis1]
description = "slotted Pyxis, overloaded"
# slotTime = pkLen/txRate = 960/9600 = 0.1s
# too frequent transmissions result in high collision rate and low channel utilization
Pyxis.host[*].iaTime = exponential(0.1s)
Pyxis.host[*].dataLen = 350	# in bytes

[Config Pyxis2]
description = "slotted Pyxis, optimal load"
# slotTime = pkLen/txRate = 960/9600 = 0.1s
# near optimal load, channel utilization is near theoretical maximum 1/e
Pyxis.host[*].iaTime = exponential(5s)
Pyxis.host[*].dataLen = 350	# in bytes

[Config Pyxis3]
description = "slotted Pyxis, low traffic"
# slotTime = pkLen/txRate = 960/9600 = 0.1s
# very low traffic results in channel being idle most of the time
Pyxis.host[*].iaTime = exponential(20s)
Pyxis.host[*].dataLen = 350	# in bytes

